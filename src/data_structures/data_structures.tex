\lstset{
style=python,
morekeywords={[2]
}
}

\section{Wbudowane typy danych}\label{sec:data_types}
\begin{frame}{Typy danych}
    W Pythonie mamy 5 prostych typów danych:
    \begin{itemize}
        \item float() - reprezentuje liczby rzeczywiste \footnote{Nie jest to do końca prawda, o czym przekonasz się na kolejnych slajdach.} \\
        \item int() - reprezentuje liczby całkowite \\
        \item str() - reprezentuje napisy - łańcuchy znaków \\
        \item bool() - reprezentuje wartości logiczne \\
        \item complex() - reprezentuje liczby urojone \\
    \end{itemize}
    Oraz 4 typy złożone:
    \begin{itemize}
        \item list() - reprezentuje zmienną grupę danych \\
        \item tuple() - reprezentuje uporządkowaną strukturę danych \\
        \item dict() - reprezentuje grupę danych, które da się indeksować \\
        \item set() - reprezentuje zbiór danych w rozumieniu teorii zbiorów \\
    \end{itemize}
\end{frame}
\begin{frame}{Proste typy danych}
    \lstinputlisting{data_structures/code/basic_types_1.py}
\end{frame}
\begin{frame}{Proste obliczenia}
    \lstinputlisting{data_structures/code/basic_types_2.py}
\end{frame}
\begin{frame}{Struktura danych - lista}
    list() - lista jednokierunkowa działa jak stos rezerwowy w grze pasjans - możemy
    podglądać jedną kartę i przesuwać się tylko do następnej. Listy dwukierunkowe
    pozwalają przesuwać się w obie strony, ale podglądamy wciąż jedną kartę. Do listy
    możemy dodawać elementy w dowolne miejsce i usuwać je.

    Lista przyjaciół: [Ala, Ola, Ela], jest równoważną liście [Ela, Ala, Ola].
    Kolejność na liście nie zawsze ma znaczenie.
\end{frame}
\begin{frame}{Struktura danych - krotka}
    tuple() - to np para, trójka, czwórka, czyli ogólnie krotka. Uporządkowany rekord
    który ma niezmienną ilość i znaczenie pól, np (3, 4) jako współrzędne na płaszczyźnie.
    Taką parę musimy interpretować w sposób x=3, y=4, nie możemy zamienić cyfr, w przeciwieństwie
    do listy znajomych.
\end{frame}
\begin{frame}{Struktura danych - słownik,mapa}
    dict() - jest jak książka telefoniczna, znając klucz
    (nazwisko) możemy wyszukać wartość (numer telefonu).
\end{frame}
\begin{frame}{Struktura danych - zbiór}
    set() - to zbiór danych w rozumieniu teorii zbiorów, czyli worek, do którego coś należy lub nie.
    Taki worek może być też wyobrażany jako słownik z tylko dwoma wartościami, True - gdy należy
    i False - gdy nie należy.

    Załóżmy że na kurs programowania chodzi 6 osób: \{Ala, Ela, Ola, Ula, Iza, Eberhard\}.

    Z rekurencją nie radzi sobie \{Ela, Ula\}.

    Metody HTTP są niezrozumiałe dla \{Ala, Ela, Iza\}.

    Algorytmów grafowych nie rozumieją \{Ela, Ola, Iza\}.

    Eberhard jako jedyny na zajęciach zadaje pytania, a w domu utrwala materiał - dlatego wszystko rozumie.

    Wymienione grupy osób są tematycznymi zbiorami, na których możemy wykonywać operację teoriomnogościowe.
\end{frame}

\begin{frame}{Ułamki}
    \begin{justify}
        Zauważmy, że:
        \begin{itemize}
            \item Każdy ułamek dziesiętny skończony lub nieskończony okresowy można zamienić w ułamek zwykły.
            Jedynie ułamka dziesiętnego nieskończonego nieokresowego nie da się zamienić. \\
            \item Każdy ułamek zwykły nieskracalny o mianowniku, będącym dzielnikiem
            jakiejś potęgi liczby 10 da się zamienić w ułamek dziesiętny skończony. \\
            \item Każdy ułamek zwykły nieskracalny o mianowniku niemającym tej własności
            jest równy pewnemu ułamkowi dziesiętnemu nieskończonemu okresowemu. \\
        \end{itemize}

        Ponieważ każdy ułamek zwykły to iloraz dwóch liczb całkowitych, więc każdy ułamek dziesiętny
        skończony lub nieskończony okresowy da się zapisać w postaci dwóch liczb całkowitych.
    \end{justify}
\end{frame}
\begin{frame}{Przeliczanie ułamków okresowych na zwykłe}
    \begin{gather*}
        0,(1234) = x | * 10000 \\
        1234,(1234) = 10000x \\
        1234,(1234) = 1234 + x \\
        1234 = 9999x \\
        x = \frac{1234}{9999} \\
        0,(1234) = \frac{1234}{9999} \\
    \end{gather*}
\end{frame}

\begin{frame}{Liczby rzeczywiste}
    Każda liczba rzeczywista jest jakimś ułamkiem dziesiętnym(również nieskończonym nieokresowym).

    Komputer jest maszyną skończoną i jako taki ma ograniczone zasoby. Z tego powodu w komputerze
    nie może przechowywać dokładnie niektórych rodzajów danych. Przykładem są liczby rzeczywiste,
    których jest nieskończenie wiele i których większość posiada nieskończone rozwinięcia dziesiętne.

    Rozpatrzmy liczbę $\pi$, która pozwoli nam lepiej zrozumieć problem.
    Poniżej przedstawiam jedynie pierwszych 1500 cyfr po przecinku jej rozwinięcia dziesiętnego.

\end{frame}
\begin{frame}{Pi, czyli 3,\dots}
    \centering
    14159265358979323846264338327950288419716939937510
    58209749445923078164062862089986280348253421170679
    82148086513282306647093844609550582231725359408128
    48111745028410270193852110555964462294895493038196
    44288109756659334461284756482337867831652712019091
    45648566923460348610454326648213393607260249141273
    72458700660631558817488152092096282925409171536436
    78925903600113305305488204665213841469519415116094
    33057270365759591953092186117381932611793105118548
    07446237996274956735188575272489122793818301194912
    98336733624406566430860213949463952247371907021798
    60943702770539217176293176752384674818467669405132
    00056812714526356082778577134275778960917363717872
    14684409012249534301465495853710507922796892589235
    42019956112129021960864034418159813629774771309960
\end{frame}
\begin{frame}{Pi, a dalej \dots}
    \centering
    51870721134999999837297804995105973173281609631859
    50244594553469083026425223082533446850352619311881
    71010003137838752886587533208381420617177669147303
    59825349042875546873115956286388235378759375195778
    18577805321712268066130019278766111959092164201989
    38095257201065485863278865936153381827968230301952
    03530185296899577362259941389124972177528347913151
    55748572424541506959508295331168617278558890750983
    81754637464939319255060400927701671139009848824012
    85836160356370766010471018194295559619894676783744
    94482553797747268471040475346462080466842590694912
    93313677028989152104752162056966024058038150193511
    25338243003558764024749647326391419927260426992279
    67823547816360093417216412199245863150302861829745
    55706749838505494588586926995690927210797509302955
\end{frame}
\begin{frame}{Liczby zmiennoprzecinkowe}
    Automat skończony jakim jest komputer nie mamy możliwości reprezentowania wszystkich liczb
    rzeczywistych, a jedynie ich mniej lub bardziej dokładne przybliżenia - mówi się, że float
    reprezentuje liczby zmiennoprzecinkowe, ponieważ w pamięci trzymane są w postaci znormalizowanej
    (czyli z przesuniętym przecinkiem) jako mantysa i wykładnik\footnote{zgodnie ze standardem IEEE 754}.
    \begin{center}
        \includegraphics[width=0.7\textwidth]{data_structures/graphics/ieee_full.png}
    \end{center}
\end{frame}

\begin{frame}{Przeliczanie liczb zmiennoprzecinkowych}
    \begin{center}
        \includegraphics[height=0.2\textheight]{data_structures/graphics/ieee_half.png} \\
        \includegraphics[height=0.45\textheight]{data_structures/graphics/calculations.png}
    \end{center}
    Program do przeliczania dla różnych precyzji: \url{http://weitz.de/ieee/}
\end{frame}

\section{Płaski model pamięci}\label{sec:memory}
\begin{frame}
    \begin{table}
        \centering
        \begin{tabular}{rc|c|}
            \cline{3-3}
            & & \\
            \cline{3-3}
            0x7999 & \longrightarrow & \cdots \\
            \cline{3-3}
            0x8000 & \longrightarrow & 00101100 \\
            \cline{3-3}
            0x8001 & \longrightarrow & 01110010 \\
            \cline{3-3}
            0x8002 & \longrightarrow & 10010101 \\
            \cline{3-3}
            0x8003 & \longrightarrow & 11011011 \\
            \cline{3-3}
            0x8004 & \longrightarrow & 10111011 \\
            \cline{3-3}
            0x8005 & \longrightarrow & 11110010 \\
            \cline{3-3}
            0x8006 & \longrightarrow & 01110001 \\
            \cline{3-3}
            0x8007 & \longrightarrow & 10110011 \\
            \cline{3-3}
            0x8008 & \longrightarrow & \cdots \\
            \cline{3-3}
            & & \\
            \cline{3-3}
        \end{tabular}
    \end{table}
\end{frame}